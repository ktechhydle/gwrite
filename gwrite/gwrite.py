import serial
import serial.tools.list_ports

class GPos:
    def __init__(self, pos: float, speed: float):
        self.p = pos
        self.s = speed

        self.r()

    def pos(self):
        return self.p

    def speed(self):
        return self.s

    def r(self):
        return self.p, self.s

class GWriteError:
    def __init__(self):
        pass

    def displayError(self, error: str):
        print(f'GWriteError: {error}')

class GWriteExtruder:
    def __init__(self):
        self.temp = 0

    def setTemp(self, temp: int):
        if temp >= 0:
            self.temp = temp
            return f'M104 S{self.temp} ; Set extruder temp'
        else:
            GWriteError.displayError(GWriteError, 'extruder temperature cannot be negative.')
            return ''

    def extrude(self, amount: float, speed: float):
        if self.temp >= 190:
            return f'G1 E{amount} F{speed} ; Extrude filament'
        else:
            GWriteError.displayError(GWriteError, 'extruder temperature not set, extrusion disabled.')
            return ''

class GWriteHeatbed:
    def __init__(self):
        self.temp = 0

    def setTemp(self, temp: int):
        if temp >= 0:
            self.temp = temp
            return f'M140 S{self.temp} ; Set heatbed temp'
        else:
            GWriteError.displayError(GWriteError, 'heatbed temperature cannot be negative.')
            return ''

class GWriteFilament:
    def __init__(self, extruderTemp: int, heatbedTemp: int):
        if extruderTemp >= 190:
            self.e = extruderTemp
        else:
            GWriteError.displayError(GWriteError, 'extruder temp cannot be less than 190 degrees celsius.')
            self.e = 0
        if heatbedTemp >= 50:
            self.h = heatbedTemp
        else:
            GWriteError.displayError(GWriteError, 'heatbed temp cannot be less than 190 degrees celsius.')
            self.h = 0

    def extruderTemp(self):
        return self.e

    def heatbedTemp(self):
        return self.h

class GWritePrinter:
    XAxis = 'x'
    YAxis = 'y'
    ZAxis = 'z'
    Heatbed = 'heatbed'
    Hotend = 'hotend'

    def __init__(self):
        self.extruder = GWriteExtruder()
        self.heatbed = GWriteHeatbed()
        self.commands: list[str] = []
        self.commands.append('; Generated by GWrite')
        self.commands.append('; Copyright (C) GWrite 2024\n\n')

    def homeAxis(self, axis):
        if axis == self.XAxis:
            self.commands.append(f'G28 X ; Home x axis')
        elif axis == self.YAxis:
            self.commands.append(f'G28 Y ; Home y axis')
        else:
            self.commands.append(f'G28 Z ; Home z axis')

    def homePrinter(self):
        self.commands.append('G28 ; Home all axis')

    def levelBed(self):
        self.commands.append('G29 ; Mesh bed leveling')
        self.commands.append('M420 S1 ; Ensure mesh bed leveling is enabled')

    def setAbsoluteMode(self):
        self.commands.append('G90 ; Set coordinates interpreted as absolute')

    def setRelativeMode(self):
        self.commands.append('G91 ; Set coordinates interpreted as relative')

    def setX(self, pos: GPos):
        self.commands.append(f'G1 X{pos.pos()} F{pos.speed()} ; Move x axis')

    def setY(self, pos: GPos):
        self.commands.append(f'G1 Y{pos.pos()} F{pos.speed()} ; Move y axis')

    def setZ(self, pos: GPos):
        self.commands.append(f'G1 Z{pos.pos()} F{pos.speed()} ; Move z axis')

    def move(self, axis, pos: GPos):
        if axis == self.XAxis:
            self.commands.append(f'G1 X{pos.pos()} F{pos.speed()} ; Move x axis')

        elif axis == self.YAxis:
            self.commands.append(f'G1 Y{pos.pos()} F{pos.speed()} ; Move y axis')

        else:
            self.commands.append(f'G1 Z{pos.pos()} F{pos.speed()} ; Move z axis')

    def createPurgeLine(self, filament: GWriteFilament, levelBed: bool = False):
        self.homePrinter()
        if levelBed:
            self.levelBed()

        self.prepareFor(filament)
        self.commands.append('; Create a purge line\n'
                             'G1 X10 Z0.2 F1000\n'
                             'G1 X70 E8 F900\n'
                             'G1 X140 E10 F700\n'
                             'G92 E0\n')

    def setFlowPercent(self, percent: int):
        self.commands.append(f'M221 S{percent} ; Set flow percent')

    def setInputShaperFrequencies(self, xFrequency: int, yFrequency: int):
        self.commands.append(f'M593 X F{xFrequency} ; Set x frequency for input shaper')
        self.commands.append(f'M593 Y F{yFrequency} ; Set y frequency for input shaper')

    def heatExtruderToTemp(self, temp: int):
        self.commands.append(self.extruder.setTemp(temp))

    def heatBedToTemp(self, temp: int):
        self.commands.append(self.heatbed.setTemp(temp))

    def prepareFor(self, filament: GWriteFilament):
        self.heatExtruderToTemp(filament.extruderTemp())
        self.heatBedToTemp(filament.heatbedTemp())

    def extrude(self, amount: GPos):
        self.commands.append(self.extruder.extrude(amount.pos(), amount.speed()))

    def cooldown(self):
        self.heatExtruderToTemp(0)
        self.heatBedToTemp(0)
        self.turnFanOn()

    def disableMotors(self):
        self.commands.append('M18 ; Disable steppers')

    def disableInputShaper(self):
        self.commands.append('M593 F0 ; Disable input shaping')

    def turnFanOn(self):
        self.commands.append('M106 ; Set fan to full speed')

    def turnFanOff(self):
        self.commands.append('M107 ; Turn fan off')

    def setFanTo(self, speed: int):
        self.commands.append(f'M106 S{speed if speed >= 1 else 0} ; Set fan to speed')

    def autotunePID(self, pid, targetTemp: int):
        if targetTemp >= 50:
            if pid == self.Hotend:
                self.commands.append(f'M303 E0 S{targetTemp}; Tune hotend PID')
            else:
                self.commands.append(f'M303 E-1 S{targetTemp}; Tune heatbed PID')
        else:
            GWriteError.displayError(GWriteError, 'target temp on PID autotune cannot be negative.')

    def displayMessage(self, message: str, playTone=False):
        self.commands.append(f'M117 {message} ; Display a message on screen')

        if playTone:
            self.playTone()

    def playTone(self, duration: int = 220, frequency: int = 440):
        self.commands.append(f'M300 S{frequency} P{duration} ; Play a tone using the speaker')

    def addCustomCommand(self, command: str):
        self.commands.append(command)

    def addComment(self, comment: str):
        self.commands.append(f'\n; {comment}\n')

    def generate(self, filename: str):
        with open(filename, 'w') as f:
            for c in self.commands:
                f.write(f'{c}\n')

            f.write(f'\n; {len(self.commands)} total lines of GCODE generated')

    def loadCodeFromFile(self, filename: str, clearExisting: bool = True):
        if clearExisting:
            self.commands.clear()
        with open(filename, 'r') as f:
            for line in f.readlines():
                self.commands.append(line)

    def sendCodeToPrinter(self, baudrate: int = 115200):
        ports = serial.tools.list_ports.comports()
        if not ports:
            GWriteError.displayError(GWriteError, 'no USB ports found')
            return

        port = ports[0].device
        try:
            with serial.Serial(port, baudrate, timeout=2) as ser:
                # Buffer commands into a single write
                commands_str = '\n'.join(self.commands) + '\n'
                ser.write(commands_str.encode())

                # Optionally read responses if needed
                for _ in self.commands:
                    response = ser.readline().decode().strip()
                    print(f'GWritePrinter response: {response}')
        except serial.SerialException as e:
            GWriteError.displayError(GWriteError, f'failed to connect to printer \n{e}')

    def storeSettings(self):
        self.commands.append('M500 ; Store settings to EEPROM')

    def end(self):
        self.commands.append('M77 ; Stop print job timer')
        self.disableSteppers()

    def clearCode(self):
        self.commands.clear()
